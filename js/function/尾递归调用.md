```javascript
function factorial(n) {
  if (n === 1) return 1
  return n * factorial(n - 1)
}
```

尾递归思路优化过后的代码：

```javascript
function factorial(n, total = 1) {
  if (n === 1) return total
  return factorial(n - 1, n * total)
}
```

它运用了尾递归，其执行速度就跟普通的循环没什么区别了，而且递归的深度也不受任何限制，也不用担心调用栈溢出或内存耗尽。

像上面第二种写法，在方法结束时出现的表达式，仅仅是自身函数调用的递归，就是尾递归。

## 尾调用

尾调用是指一个函数里最后一个动作是返回一个函数的调用结果的情况，即最后一步新调用的返回值直接被当作函数的返回结果。

其实 JavaScript 解释器之所以能够优化尾递归的执行效率，本质上是因为其对尾调用的优化。

## 尾调用优化

当一个函数调用发生时，电脑必须记住调用函数的位置——返回位置，才可以在调用结束后时带着返回值回到该位置，返回位置一般存在调用栈上。
在尾调用这种特殊情形中，电脑理论上可以不需要记住尾调用的位置而从被调用的函数直接带着返回值返回调用函数的返回位置（相当于直接返回两次）。
尾调用消除即是在不改变当前调用栈（也不添加新的返回位置）的情况下调到新函数的一种优化（完全不改变调用栈是不可能的，还是需要校正调用栈上形式参数与局部变量的信息）。

由于当前函数帧上包含局部变量等等大部分东西都不需要了，当前的函数帧经过适当的更动以后可以直接被当作被尾调用的函数的帧使用，然后程序即可以跳到被尾调用的函数。
产生这种函数帧更动代码与“jump”（而不是一般常规函数调用的代码）的过程称作尾调用消除（Tail Call Elimination）或尾调用优化（Tail Call Optimization）。
尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。

## 参考

- https://www.freecodecamp.org/chinese/news/js-tail-recursion/
