JavaScript 是在创建变量（对象、字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。
释放的过程称为垃圾回收（garbage collection）。

## 引用

垃圾回收算法主要依赖于引用的概念。
在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。
例如，一个 JavaScript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。

在这里，“对象”的概念不仅指 JavaScript 对象，还包括函数作用域（或者全局作用域）。

## 引用计数垃圾收集

这是最初级的垃圾回收算法。
该算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。
如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

### 限制：循环引用

该算法有个限制，无法处理循环引用的事例。
在下面的例子中，两个对象被创建，并相互引用，形成了一个循环。
它们被调用之后会离开函数作用域，因此它们已经没有用了，可以被回收了。
然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

```javascript
function f() {
  var o1 = {}
  var o2 = {}
  o1.p = o2
  o2.p = o1
}
f()
```

## 标记-清除算法

这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。

这个算法假定设置一个叫做根（root）的对象（在 JavaScript 里，根是全局对象）。
垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……
从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。

### 循环引用不再是问题了

在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。
因此，他们将被垃圾回收器回收。

## 参考

- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_management
