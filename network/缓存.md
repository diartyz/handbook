## 文档过期

服务器用 HTTP/1.0+ 的 Expires 首部或 HTTP/1.1 的 Cache-Control：max-age 响应首部来指定过期日期，
同时还会带有响应主体。它们所做的事情本质上是一样的，但由于 Cache-Control 首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的 Cache-Control 首部。

## 服务器再验证

仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。这种情况被称为服务器再验证，说明缓存需要询问原始服务器文档是否发生了变化。

- 如果再验证显示内容发生了变化，缓存会获取一份新的文档副本，并将其存储在旧文档的位置上，然后将文档发送给客户端。
- 如果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。

## 用条件方法进行再验证

向 GET 请求报文中添加一些特殊的条件首部，就可以发起条件 GET，只有条件为真时，Web 服务器才会返回对象。

HTTP 定义了 5 个条件请求首部，对缓存再验证来说最有用的 2 个首部是 If-Modified-Since 和 If-None-Match。

如果服务器回送了一个实体标签，HTTP/1.1 客户端就必须使用实体标签验证器。如果服务器只回送了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证。如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案。

如果 HTTP/1.1 缓存或服务器收到的请求既带有 If-Modified-Since，又带有实体标签首部，那么只有这两个条件都满足时，才能返回 304 Not Modified 响应。

### If-Modified-Since：Date 再验证

- 如果自指定日期后，文档被修改了，If-Modified-Since 条件就为真，通常 GET 请求就会成功执行，携带新首部的新文档会被返回给缓存，新首部除了其他信息之外，还包含了一个新的过期日期。
- 如果自指定日期后，文档没被修改过，条件就为假，会向客户端返回一个小的 304 Not Modified 响应报文。这些首部是放在响应中返回的，但只会返回那些需要在源端更新的首部。

### If-None-Match：实体标签再验证

HTTP 允许用户对被称为实体标签（ETag）的 “版本标识符” 进行比较。

如果标签仍然匹配，那么会返回一条 304 Not Modified 响应；如果服务器上的实体标签已经发生了变化，服务器会在一个 200 OK 响应中返回新的内容以及响应的 ETag。

## 控制缓存的能力

标识为 no-store 的响应会禁止缓存对响应进行复制，缓存通常会像非缓存代理服务器一样，向客户端转发一条 no-store 响应，然后删除对象。

标识为 no-cache 的响应实际上是可以存储在本地缓存区中的，只是在与原始服务器进行新监督再验证之前，缓存不能将其提供给客户端使用。

如果响应中没有 Cache-Control，也没有 Expires 首部，缓存可以计算出一个试探性最大使用期。

## 参考

- 《HTTP权威指南》
