## 性能

用户期待内容快速加载和交互流畅的 Web 体验。

等待资源加载时间和大部分情况下的浏览器单线程执行是影响 Web 性能的两大主要原因。

## 导航

### DNS 查询

对一个 web 页面来说导航的第一步是要去寻找页面资源的位置，如果以前没有访问过这个网站，就需要进行 DNS 查询。
浏览器向名称服务器发起 DNS 查询请求，最终得到一个 IP 地址。
第一次请求之后，这个 IP 地址可能会被缓存一段时间，这样可以通过从缓存里面检索 IP 地址来加速后续的请求。

通过主机名加载一个页面通常仅需要一次 DNS 查询。
但是，对于页面指向的不同的主机名，则需要多次 DNS 查询。
如果字体（fonts）、图像（images）、脚本（scripts）、广告（ads）和网站统计（metrics）都有不同的主机名，则需要对每一个主机名进行 DNS 查询。

### TCP 握手

一旦获取到服务器 IP 地址，浏览器就会通过 TCP 三次握手与服务器建立连接。
通过 TCP 首先发送三个消息进行协商，然后在两台电脑之间开始一个 TCP 会话。
这意味着终端与每台服务器之间还要来回发送三条消息，而请求尚未发出。

### TLS 协商

为了在 HTTPS 上建立安全连接，TLS 协商是必须的。
它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。

## 响应

一旦我们建立了到 Web 服务器的连接，浏览器就代表用户发送一个 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。
一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。

Time to First Byte（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。

### TCP 慢启动 / 14KB 规则

第一个响应包是 14KB 大小的。
这是慢启动的一部分，慢启动是一种均衡网络连接速度的算法。
在 TCP 慢启动中，在收到初始包之后，服务器会将下一个数据包的大小加倍到大约 28KB。
后续的数据包依次是前一个包大小的两倍直到达到预定的阈值，或者遇到拥塞。

### 拥塞控制

当服务器用 TCP 数据包来发送数据时，客户端通过返回确认帧来确认传输。
如果服务器太快地发送太多包，它们可能会被丢弃，将不会有确认帧的返回。
拥塞控制算法使用这个数据包和确认帧流来确定发送速率。

## 解析

一旦浏览器收到数据的第一块，它就可以开始解析收到的消息。
解析是浏览器将通过网络接收的数据转换为 DOM 和 CSSDOM 的步骤，通过渲染器把 DOM 和 CSSDOM 在屏幕上绘制成页面。

即使请求页面的 HTML 大于初始的 14KB 数据包，浏览器也将开始解析并尝试根据其拥有的数据进行渲染。
这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容，或者至少包含页面模版（第一次渲染所需的 CSS 和 HTML）对于 Web 性能优化来说是重要的。
但是在渲染到屏幕上面之前，HTML、CSS、JavaScript 必须被解析完成。

### 构建 DOM 树

第一步是处理 HTML 标记并构造 DOM 树。
当解析器发现非阻塞资源，例如一张图片，浏览器会请求这些资源并且继续解析。
当遇到一个 CSS 文件时，解析也可以继续进行。
但是对于 `<script>` 标签（特别是没有 aysnc 或者 defer 属性的）会阻塞渲染并停止 HTML 的解析。

### 预加载扫描器

浏览器构建 DOM 树时，这个过程占用了主线程。
预加载扫描器将在后台解析可用的内容并请求高优先级资源，如 CSS、JavaScript 和 web 字体。
以便在主 HTML 解析器到达请求的资源时，它们可能已经在运行，或者已经被下载。

等待获取 CSS 不会阻塞 HTML 的解析或下载，但是它确实会阻塞 JavaScript，因为 JavaScript 经常用于查询元素的 CSS 属性。

### 构建 CSSDOM 树

第二步是处理 CSS 并构建 CSSDOM 树。
DOM 和 CSSDOM 是两棵树，它们是独立的数据结构。

### JavaScript 编译

脚本被解析为抽象语法树。
一些浏览器引擎抽象语法树并将其传递到解释器中，输出在主线程上执行的字节码。
这就是所谓的 JavaScript 编译。

### 构建辅助功能树

无障碍对象模型（AOM）类似于 DOM 的语意版本。
当 DOM 更新时，浏览器会更新辅助功能树。
在构建 AOM 之前，屏幕阅读区无法访问内容。

## 渲染

渲染步骤包括样式、布局、绘制，在某些情况下还包括合成。
在解析步骤中创建的 CSSDOM 树和 DOM 树组合成一个 Render 树，然后用于计算每个可见元素的布局，然后将其绘制到屏幕上。
在某些情况下，可以将内容提升到它们自己的层并进行合成，通常在 GPU 而不是 CPU 上绘制屏幕的一部分来提高性能，从而释放主线程。

### Style

第三步是将 DOM 和 CSSDOM 组合成一个 Render 树，计算样式树或渲染树从 DOM 树的根开始构建，遍历每个可见节点。

任何具有 `display: none` 的节点不会出现在 Render 树上。
具有 `visibility: hidden` 的节点会出现在 Render 树上，因为它们会占用空间。

### Layout

第四步是在渲染树上运行布局以计算每个节点的几何体。

布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。
回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。

第一次确定节点的大小和位置称为布局。
随后对节点大小和位置的重新计算称为回流。

### 绘制

最后一步是将各个节点绘制到屏幕上，包括文本、颜色、边框、阴影和替换的元素（如按钮和图像）。

为了确保平滑滚动和动画，占据主线程的所有内容，包括计算样式，以及回流和绘制，必须让浏览器在 16.67 毫秒内完成。

绘制可以将布局树中的元素分解为多个层。
将内容提升到 GPU 上的层（而不是 CPU 的主线程）可以提高绘制和重新绘制性能。

分层确实可以提高性能，但是它以内存管理为代价，因此不应作为 Web 性能优化策略的一部分过度使用。

### Compositing

当文档的各个部分以不同的层绘制，相互重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上。

当页面继续加载资源时，可能会发生回流（比如图片），回流会触发重新绘制和重新组合。
如果我们定义了图像的大小，就不需要重新绘制，只需要重新绘制需要重新绘制的层，并在必要时进行合成。

## 交互

如果加载包含 JavaScript（并且延迟到 onload 时间触发后执行），则主线程可能很忙，无法用于滚动、触摸和其他交互。

Time to Interactive（TTI）是测量从第一个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间。

## 参考

- https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work
